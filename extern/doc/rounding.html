<HTML><!-- #BeginTemplate "/Templates/self-similar%20page.dwt" -->
<HEAD>
<BASE HREF="http://www.self-similar.com/rounding.html">

<!-- #BeginEditable "doctitle" --> 
<TITLE>Self-Similar</TITLE>
<!-- #EndEditable --> 
<meta http-equiv="Content-Type" content="text/html; charset=">
</HEAD>

<BODY BGCOLOR="#FFFFFF">
<h2 align="center">&nbsp;</h2>
<p align="center"></p>
<div align="center"> 
  <table width="450" border="0" bordercolorlight="#000000" cellspacing="0" bordercolordark="#FFFFFF" cellpadding="2">
    <tr> 
      <td colspan="2"><!-- #BeginEditable "More%20Content" --> 
        <div align="center"> 
          <table width="450" border="0">
            <tr> 
              <th>Rounding Floats</th>
            </tr>
            <tr> 
              <td> 
                <p>If you decide to convert a floating point number to an integer, 
                  there are several options. You can </p>
                <ol>
                  <li>Choose nearest nearest integer towards zero (called <strong>trunc</strong>, 
                    or <strong>chop</strong>)</li>
                  <li>Choose nearest integer away from zero</li>
                  <li>Choose nearest integer (called <strong>round</strong>, or 
                    <strong>near</strong>). in case of ambiguity (as with 0.5), 
                    you can again choose the direction (towards zero, away from 
                    zero, towards plus infinity, towards minus infinity, towards 
                    an even number, towards an odd number).</li>
                  <li>Choose nearest integer towards plus infinity (called <strong>ceiling</strong>, 
                    or <strong>up</strong>)</li>
                  <li>Choose nearest integer towards minus infinity (called <strong>floor</strong>, 
                    or <strong>down</strong></li>
                </ol>
                <hr noshade size="1">
                <p>As you can see, with 10 algorithms available, it's not entirely 
                  obvious which option to choose. If you use <strong>round</strong>, 
                  you guarantee an error of at most 0.5. With all other methods, 
                  the error can be nearly 1. The <strong>round</strong> method 
                  is widely used for numeric computations, because it is the most 
                  accurate. By default, Pentium's <strong>fistp</strong> instruction 
                  uses <strong>round towards even</strong>. This is the most sensible 
                  choice. This means that the nearest integer is chosen, and in 
                  case of a conflict, an even number is chosen. The reason for 
                  rounding towards an even number is that if you take a large 
                  number of integers, each plus .5, after rounding the total &quot;drift&quot; 
                  will be zero.</p>
                <p>C and C++ use <strong>trunc</strong>. Nobody probably remembers 
                  the reason for trunc as method of choice. Maybe so that you 
                  could split a float into its integer and fractional parts? It 
                  seems that a better choice would be to prohibit an implicit 
                  conversion from float to int, forcing the programmer to choose 
                  a function like Round, Floor, Ceiling, or Trunc.</p>
                <p>The C runtime library in some cases provides a function &quot;<strong>rint</strong>&quot; 
                  (which rounds towards current mode), in addition to &quot;<strong>floor</strong>&quot;, 
                  and &quot;<strong>ceil</strong>&quot;. Current rounding mode 
                  is usually a global setting in the processor. The IEEE754 standard 
                  has a lot of rules regarding this issue.</p>
                <p>There is a significant performance penalty in Microsoft Visual 
                  C++ for implicitely converting a float to an int. When you write</p>
                <table width="75%" border="0" cellspacing="0" cellpadding="0" bordercolor="#333333">
                  <tr> 
                    <td bgcolor="#FFFFCC"> 
                      <pre>float f = 0.5;
int i = int(f);</pre>
                    </td>
                  </tr>
                </table>
                <p>VC++ generates a call to function <strong>ftol</strong>, which 
                  saves current processor's rounding mode, sets it to <strong>floor</strong>, 
                  executes instruction <strong>fistp</strong>, then pops everything 
                  back. So instead of one instruction (fistp), you get a function 
                  call plus this:</p>
                <table width="75%" border="0" cellspacing="0" cellpadding="0" bordercolor="#333333">
                  <tr> 
                    <td bgcolor="#FFFFCC"> 
                      <pre>1024B094 push ebp
1024B095 mov ebp,esp
1024B097 add esp,0F4h
1024B09A wait
1024B09B fnstcw word ptr [ebp-2]
1024B09E wait
1024B09F mov ax,word ptr [ebp-2]
1024B0A3 or ah,0Ch
1024B0A6 mov word ptr [ebp-4],ax
1024B0AA fldcw word ptr [ebp-4]
1024B0AD fistp qword ptr [ebp-0Ch]
1024B0B0 fldcw word ptr [ebp-2]
1024B0B3 mov eax,dword ptr [ebp-0Ch]
1024B0B6 mov edx,dword ptr [ebp-8]
1024B0B9 leave
1024B0BA ret</pre>
                    </td>
                  </tr>
                </table>
                <p>The following function can be used to achieve a great efficiency 
                  gain:</p>
                <table width="75%" border="0" cellspacing="0" cellpadding="0" bordercolor="#333333">
                  <tr> 
                    <td bgcolor="#FFFFCC"> 
                      <pre>inline int Round(float a) {
#ifdef WIN32
	int i;
	__asm {
		fld   a
		fistp i
	}
	return i;
#else
	return rint(a); // just hope it's an intrinsic.
#endif
}</pre>
                    </td>
                  </tr>
                </table>
                <p>To get truncation, the function below can be used:</p>
                <table width="75%" border="0" cellspacing="0" cellpadding="0" bordercolor="#333333">
                  <tr> 
                    <td bgcolor="#FFFFCC"> 
                      <pre>inline int Trunc(float f) {
#ifdef WIN32
	int magic = 0x3efffffe | (int&amp;)f &amp; 0x80000000;
	return Round(f - *(float*)&amp;magic);
#else
	return int(f);
#endif
}</pre>
                    </td>
                  </tr>
                </table>
                <p>Function Trunc does the following for positive numbers: return 
                  Round(f - magic), where &quot;magic&quot; is the largest number 
                  less than 1. For negative numbers, additional two instructions 
                  are required negate this &quot;magic&quot; number. Note that 
                  this function is only suitable for computer graphics. It's no 
                  good for other kinds of computation, because it doesn't handle 
                  special cases at all.</p>
                <p>It would be more efficient to modify the default rounding mode 
                  before a series of truncations, then restore it back This can 
                  be done with the <strong>_controlfp</strong> function.</p>
                <table width="75%" border="0" cellspacing="0" cellpadding="0" bordercolor="#333333">
                  <tr> 
                    <td bgcolor="#FFFFCC"> 
                      <pre>unsigned int saved = _statusfp();
_controlfp(_MCW_RC,_RC_CHOP);   
// RC == Rounding Control<b>, </b>CHOP == Truncate<b>
</b>// use Round() to truncate many numbers
_controlfp(_MCW_RC,saved);</pre>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </div>
        <!-- #EndEditable --></td>
    </tr>
  </table>
  <p align="center">&nbsp;</p>
</div>
<div align="center">
  <table width="600" border="0" cellspacing="0" cellpadding="2" bordercolorlight="#000000" bordercolordark="#FFFFFF">
    <tr> 
      <td width="33%"><a href="/index.html">www.self-similar.com</a></td>
      <td width="33%"> 
        <div align="center"><a href="mailto:alexei@self-similar.com">e-mail</a></div>
      </td>
      <td width="33%"> 
        <div align="right">&copy; 1996-2003 Alexei Lebedev</div>
      </td>
    </tr>
  </table>
</div>
<p align="center">&nbsp;</p>
</BODY>
<!-- #EndTemplate -->
<SCRIPT language="Javascript">
<!--

// FILE ARCHIVED ON 20041011125702 AND RETRIEVED FROM THE
// INTERNET ARCHIVE ON 20060329063645.
// JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.
// ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
// SECTION 108(a)(3)).

   var sWayBackCGI = "http://web.archive.org/web/20041011125702/";

   function xLateUrl(aCollection, sProp) {
      var i = 0;
      for(i = 0; i < aCollection.length; i++)
         if (aCollection[i][sProp].indexOf("mailto:") == -1 &&
             aCollection[i][sProp].indexOf("javascript:") == -1)
            aCollection[i][sProp] = sWayBackCGI + aCollection[i][sProp];
   }

   if (document.links)  xLateUrl(document.links, "href");
   if (document.images) xLateUrl(document.images, "src");
   if (document.embeds) xLateUrl(document.embeds, "src");

   if (document.body && document.body.background)
      document.body.background = sWayBackCGI + document.body.background;

//-->

</SCRIPT>
</HTML>
